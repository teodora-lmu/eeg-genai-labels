<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>AI Image Rating Task</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .container { max-width: 700px; margin: auto; }
    img { width: 100%; max-height: 320px; object-fit: contain; margin-bottom: 20px; border-radius: 6px; }
    .slider-labels { display: flex; justify-content: space-between; font-size: 0.9em; color: #555; margin-bottom: 6px; }
    #slider, #confidenceSlider { width: 100%; }
    #nextButton { padding: 10px 16px; font-size: 1rem; border: none; border-radius: 6px; background: #2d6cdf; color: #fff; }
    #nextButton:disabled { background-color: #ccc; cursor: not-allowed; }
    #progress { font-size: 0.9em; color: #333; margin-bottom: 10px; text-align: right; }
    .hidden { display: none; }
    .note { font-size: 0.9em; color: #555; margin-bottom: 8px; }
  </style>

  <!-- Firebase SDK (ESM) -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-auth.js";
    import {
      getFirestore, doc, getDoc, setDoc, runTransaction
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";

    // ======= 0) CONFIG: REPLACE WITH YOURS =======
    const firebaseConfig = {
      apiKey: "AIzaSyDZ2S2cdztJc7Xh9PKBHHtSJP5Z-ZitRHY",
      authDomain: "ai-labels-4a313.firebaseapp.com",
      projectId: "ai-labels-4a313",
    };

    // ======= 1) INIT FIREBASE =======
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // Expose Firestore for non-module scripts below
    window.__FIREBASE__ = { db, auth, onAuthStateChanged, signInAnonymously };
  </script>
</head>
<body>
  <div class="container">
    <div class="note">Target: <strong>30 ratings per image</strong>. Images stop showing once full.</div>
    <div id="ratingInterface">
      <div id="progress">Loading…</div>
      <img id="imageToRate" src="" alt="Image to rate" />

      <p><strong>This image was created with the help of generative AI.</strong></p>

      <div class="slider-section">
        <div class="slider-labels">
          <span>Strongly Disagree</span>
          <span>Strongly Agree</span>
        </div>
        <input type="range" id="slider" min="1" max="100" value="50" />
      </div>

      <br />
      <label for="confidenceSlider"><strong>I am confident in my response.</strong></label>
      <div class="slider-labels">
        <span>Strongly Disagree</span>
        <span>Strongly Agree</span>
      </div>
      <input type="range" id="confidenceSlider" min="1" max="100" value="50" />

      <br /><br />
      <button id="nextButton" disabled>Next Image</button>
    </div>

    <div id="confirmationPage" class="hidden">
      <h2>Thank you!</h2>
      <p>You have rated all available images. Please click the arrow below to continue.</p>
    </div>
  </div>

  <!-- Your app logic -->
  <script>
    // ===================== 2) PARAMETERS =====================
    const TARGET_RATINGS = 30;
    const PER_CELL = 5;  // images per (gender×ethnicity) cell per participant

    // ======= 2a) IMAGE LIST (paste your full list here) =======
    const imagePaths = [
      /* --- shortened here for brevity in this example ---
         Paste your full array from your message (all the imagePaths) */
      "stimuli/ai_generated/man_filtered/asian/man_1186.jpg",
      "stimuli/ai_generated/woman_filtered/white/woman_0104.jpg",
      // ... all others ...
    ];

    // ===================== 3) FOLD LOGIC (unchanged) =====================
    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
    function hashString(str) {
      let h = 5381;
      for (let i = 0; i < str.length; i++) { h = ((h << 5) + h) + str.charCodeAt(i); h &= 0xffffffff; }
      return Math.abs(h);
    }
    function getGenderAndEthnicity(path) {
      const parts = path.split("/");
      const genderFiltered = parts[2];
      const ethnicity = parts[3];
      const gender = genderFiltered.startsWith("man") ? "man" : "woman";
      return { gender, ethnicity };
    }
    function buildBuckets(paths) {
      const buckets = {
        man:   { asian: [], black: [], latino: [], white: [] },
        woman: { asian: [], black: [], latino: [], white: [] }
      };
      for (const p of paths) {
        const { gender, ethnicity } = getGenderAndEthnicity(p);
        if (buckets[gender] && buckets[gender][ethnicity]) buckets[gender][ethnicity].push(p);
      }
      return buckets;
    }
    function deterministicSort(arr) { return arr.slice().sort(); }
    function splitIntoFolds(buckets, perCell) {
      const sizes = [];
      for (const g of ["man","woman"]) {
        for (const e of ["asian","black","latino","white"]) {
          const n = buckets[g][e].length;
          if (n < perCell) throw new Error(`Bucket short: ${g}/${e} has ${n}, needs ≥ ${perCell}.`);
          sizes.push(Math.floor(n / perCell));
        }
      }
      const K = Math.min(...sizes);
      if (K < 1) throw new Error("Not enough images to create even a single fold.");
      const folds = Array.from({ length: K }, () => ({
        man:   { asian: [], black: [], latino: [], white: [] },
        woman: { asian: [], black: [], latino: [], white: [] }
      }));
      for (const g of ["man","woman"]) {
        for (const e of ["asian","black","latino","white"]) {
          const ordered = deterministicSort(buckets[g][e]);
          const needed = K * perCell;
          if (ordered.length < needed) throw new Error(`Bucket ${g}/${e} needs ${needed} images (has ${ordered.length}).`);
          for (let k = 0; k < K; k++) {
            const start = k * perCell;
            const end   = start + perCell;
            folds[k][g][e] = ordered.slice(start, end);
          }
        }
      }
      return { folds, K };
    }

    // ===================== 4) FIRESTORE HELPERS =====================
    function imageDoc(path) {
      const { db } = window.__FIREBASE__;
      return firebase.firestoreDoc || null; // placeholder to appease IDEs
    }
  </script>

  <!-- Firestore helpers that require ESM imports from the head script -->
  <script type="module">
    import {
      doc, getDoc, setDoc, runTransaction
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";

    // Attach helpers to window for non-module script
    window.__FS_HELPERS__ = {
      imageDoc: (path) => doc(window.__FIREBASE__.db, "imageCounts", encodeURIComponent(path)),
      ensureImageDoc: async (path) => {
        const d = doc(window.__FIREBASE__.db, "imageCounts", encodeURIComponent(path));
        const snap = await getDoc(d);
        if (!snap.exists()) {
          await setDoc(d, { count: 0, raters: {} }, { merge: true });
          return { count: 0, raters: {} };
        }
        return snap.data();
      },
      reserveImage: async (path, participantId, cap = 30) => {
        const d = doc(window.__FIREBASE__.db, "imageCounts", encodeURIComponent(path));
        return runTransaction(window.__FIREBASE__.db, async (tx) => {
          const snap = await tx.get(d);
          const data = snap.exists() ? snap.data() : { count: 0, raters: {} };

          // Already counted for this participant?
          if (data.raters && data.raters[participantId]) {
            return { ok: true, alreadyCounted: true, count: data.count || 0 };
          }
          if ((data.count || 0) >= cap) {
            return { ok: false, reason: "full", count: data.count || 0 };
          }
          const newCount = (data.count || 0) + 1;
          const newRaters = { ...(data.raters || {}), [participantId]: true };
          tx.set(d, { count: newCount, raters: newRaters }, { merge: true });
          return { ok: true, alreadyCounted: false, count: newCount };
        });
      }
    };
  </script>

  <!-- Main app flow -->
  <script>
    // Glue non-module + module parts
    const { imageDoc, ensureImageDoc, reserveImage } = window.__FS_HELPERS__;

    // Prefer images that are below cap, sorted by current count ascending
    async function getEligibleImagePaths(paths) {
      const results = [];
      for (const p of paths) {
        const data = await ensureImageDoc(p);
        const cnt = data?.count || 0;
        if (cnt < TARGET_RATINGS) results.push({ path: p, count: cnt });
      }
      results.sort((a, b) => a.count - b.count || a.path.localeCompare(b.path));
      return results.map(r => r.path);
    }

    async function buildAssignedSetRespectingCaps(paths, participantId, perCell = PER_CELL) {
      const underCap = await getEligibleImagePaths(paths);
      const buckets = buildBuckets(underCap);
      const { folds, K } = splitIntoFolds(buckets, perCell);
      const id = (participantId && participantId !== "unknown") ? participantId : ("" + Math.random());
      const foldIndex = hashString(id) % K;

      const candidate = [];
      for (const g of ["man","woman"]) {
        for (const e of ["asian","black","latino","white"]) candidate.push(...folds[foldIndex][g][e]);
      }
      return shuffle(candidate);
    }

    // ===================== 5) UI / TASK LOGIC =====================
    const defaultSliderValue = 50;
    let shuffledImages = [];
    let totalImages = 0;
    let currentIndex = 0;
    let startTime = null;
    let currentImage = null;
    let participantId = null;

    const elProgress = document.getElementById("progress");
    const elImg = document.getElementById("imageToRate");
    const elSlider = document.getElementById("slider");
    const elConf = document.getElementById("confidenceSlider");
    const elNext = document.getElementById("nextButton");

    function getProlificID() {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get("PROLIFIC_PID") || "unknown";
    }

    const responseData = { participant_id: null, responses: [] };

    function updateProgress() {
      elProgress.textContent =
        `Image ${Math.min(currentIndex + 1, totalImages)} of ${totalImages} (aim: ${TARGET_RATINGS}/image)`;
      elNext.textContent = (currentIndex >= totalImages - 1) ? "Finish" : "Next Image";
    }

    function showConfirmationPage() {
      document.getElementById("ratingInterface").classList.add("hidden");
      document.getElementById("confirmationPage").classList.remove("hidden");
      // Send JSON to parent (Qualtrics)
      window.parent.postMessage({ type: "ai_image_rating_data", payload: responseData }, "*");
    }

    async function getNextReservableImage(startIdx) {
      for (let i = startIdx; i < shuffledImages.length; i++) {
        const img = shuffledImages[i];
        const res = await reserveImage(img, participantId, TARGET_RATINGS);
        if (res.ok) {
          return { index: i, path: img };
        }
        // if full, try the next
      }
      return null;
    }

    async function loadNextImage() {
      const next = await getNextReservableImage(currentIndex);
      if (!next) {
        showConfirmationPage();
        return;
      }
      currentIndex = next.index + 1;  // move past the reserved one
      currentImage = next.path;

      elImg.src = currentImage;
      elSlider.value = defaultSliderValue;
      elConf.value = defaultSliderValue;
      elNext.disabled = true;
      startTime = Date.now();
      updateProgress();
    }

    async function submitResponse() {
      const endTime = Date.now();
      const timeTaken = ((endTime - startTime) / 1000).toFixed(2);
      const sliderValue = elSlider.value;
      const confidenceValue = elConf.value;
      const groundTruth = currentImage.includes("ai_generated") ? "Yes" : "No";

      responseData.responses.push({
        image: currentImage,
        rating: sliderValue,
        confidence: confidenceValue,
        time: parseFloat(timeTaken),
        ground_truth_ai: groundTruth
      });

      await loadNextImage();
    }

    function checkInputCompletion() {
      const ratingMoved = elSlider.value != defaultSliderValue;
      const confidenceMoved = elConf.value != defaultSliderValue;
      elNext.disabled = !(ratingMoved && confidenceMoved);
    }

    // ===================== 6) BOOTSTRAP =====================
    async function init() {
      const { onAuthStateChanged, signInAnonymously, auth } = window.__FIREBASE__;
      elProgress.textContent = "Initializing…";

      await signInAnonymously(auth).catch(console.error);

      onAuthStateChanged(auth, async (user) => {
        if (!user) return;
        participantId = getProlificID() || user.uid;  // prefer PROLIFIC_PID, else anon uid
        responseData.participant_id = participantId;

        try {
          shuffledImages = await buildAssignedSetRespectingCaps(imagePaths, participantId, PER_CELL);
          totalImages = shuffledImages.length;   // may be < 40 near completion
          await loadNextImage();
        } catch (e) {
          console.error(e);
          alert(e.message || "Initialization error.");
        }
      });
    }

    elSlider.addEventListener("input", checkInputCompletion);
    elConf.addEventListener("input", checkInputCompletion);
    elNext.addEventListener("click", submitResponse);

    window.addEventListener("load", () => { init(); });
  </script>
</body>
</html>
